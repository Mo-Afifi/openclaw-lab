<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HIFI Solar System Org Model</title>
    <style>
        body {
            margin: 0;
            background-color: #0a0a0f;
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .title {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            color: #fff;
        }
        .subtitle {
            font-size: 12px;
            color: #888;
            letter-spacing: 1px;
        }
        #tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 20;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .tooltip-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            color: #00f3ff;
        }
        .tooltip-tasks {
            font-size: 12px;
            color: #aaa;
        }
        #sprint-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            padding: 15px;
            background: rgba(10, 10, 15, 0.8);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 4px;
            display: none;
            z-index: 15;
            backdrop-filter: blur(10px);
        }
        .sprint-title {
            color: #00f3ff;
            font-weight: bold;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <div class="title">HIFI SYSTEM</div>
        <div class="subtitle">SERIES A ORG ARCHITECTURE</div>
    </div>
    <div id="tooltip"></div>
    <div id="sprint-info">
        <div class="sprint-title">SWAT TEAM FORMING</div>
        <div id="sprint-details" style="font-size: 12px; color: #ccc; line-height: 1.4;"></div>
        <div style="margin-top: 10px; font-size: 10px; color: #666;">POD ROTATION PAUSED</div>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/21.0.0/tween.umd.js"></script>

    <script>
        // --- Configuration ---
        const COLORS = {
            CORE: 0xffffff,
            COMPLIANCE: 0xff00ff,
            MARKETING: 0xffaa00,
            ENGINEERING: 0x00f3ff,
            GTM: 0x00ff00,
            OPS: 0xff5500,
            FTE: 0x888888,
            JEFF: 0x00f3ff
        };

        const BARRELS = [
            { name: "Compliance", color: COLORS.COMPLIANCE, angle: 0 },
            { name: "Marketing", color: COLORS.MARKETING, angle: (Math.PI * 2) / 5 },
            { name: "Engineering", color: COLORS.ENGINEERING, angle: (Math.PI * 2 * 2) / 5 },
            { name: "GTM", color: COLORS.GTM, angle: (Math.PI * 2 * 3) / 5 },
            { name: "Ops", color: COLORS.OPS, angle: (Math.PI * 2 * 4) / 5 }
        ];

        const TASK_TYPES = [
            "Smart Contract Audit", "Latency Optimization", "Growth Loop Design", 
            "Liquidity Scaling", "Risk Assessment", "API Integration", 
            "Brand Narrative", "Yield Strategy", "System Architecture",
            "Regulatory Mapping", "Partner Relations", "CI/CD Pipeline"
        ];

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 40);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        const group = new THREE.Group();
        scene.add(group);

        // --- Interaction State ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        let activeSprint = null;

        // --- Components ---
        const ftes = [];
        const barrelNodes = [];
        const lightningLines = [];

        // LAYER 1: CORE
        function createCore() {
            const coreGroup = new THREE.Group();
            
            const createNode = (name, x) => {
                const geo = new THREE.SphereGeometry(1.2, 32, 32);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = x;
                
                // Glow
                const glowGeo = new THREE.SphereGeometry(1.6, 32, 32);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.2 
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                mesh.add(glow);
                mesh.userData = { type: 'core', name: name };
                return mesh;
            };

            const mo = createNode("Mo", -1.5);
            const zack = createNode("Zack", 1.5);
            coreGroup.add(mo, zack);
            group.add(coreGroup);
            
            // Pulsing animation
            function pulse() {
                const s = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                mo.scale.set(s, s, s);
                zack.scale.set(s, s, s);
                requestAnimationFrame(pulse);
            }
            pulse();
        }

        // LAYER 2: BARREL RING
        function createBarrels() {
            BARRELS.forEach((b, i) => {
                const barrelPivot = new THREE.Group();
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 1.8, 1.8),
                    new THREE.MeshBasicMaterial({ color: b.color })
                );
                mesh.position.set(Math.cos(b.angle) * 10, 0, Math.sin(b.angle) * 10);
                
                // Glow
                const glow = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 2.2, 2.2),
                    new THREE.MeshBasicMaterial({ color: b.color, transparent: true, opacity: 0.3 })
                );
                mesh.add(glow);
                mesh.userData = { type: 'barrel', name: b.name, color: b.color };
                
                group.add(mesh);
                barrelNodes.push(mesh);

                // Task Beams
                const beamGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1)
                ]);
                const beamMat = new THREE.LineBasicMaterial({ color: b.color, transparent: true, opacity: 0.5 });
                
                setInterval(() => {
                    const beam = new THREE.Line(beamGeo, beamMat);
                    beam.position.copy(mesh.position);
                    const targetAngle = Math.random() * Math.PI * 2;
                    beam.lookAt(new THREE.Vector3(
                        Math.cos(targetAngle) * 30, 
                        (Math.random()-0.5) * 10, 
                        Math.sin(targetAngle) * 30
                    ));
                    group.add(beam);
                    
                    new TWEEN.Tween(beam.scale)
                        .to({ z: 20 }, 1000)
                        .onComplete(() => group.remove(beam))
                        .start();
                }, 800 + Math.random() * 1000);
            });
        }

        // LAYER 3: SWAT RING
        function createFTEs() {
            for (let i = 1; i <= 45; i++) {
                const ringId = Math.floor((i-1) / 15); // 3 rings
                const radius = 18 + ringId * 4;
                const angle = ((i-1) % 15) * (Math.PI * 2 / 15);
                
                const mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: COLORS.FTE })
                );
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                mesh.position.set(x, 0, z);
                
                mesh.userData = {
                    id: i,
                    name: `Unit ${String(i).padStart(2, '0')}`,
                    type: 'fte',
                    ringRadius: radius,
                    originalAngle: angle,
                    orbitSpeed: 0.001 + Math.random() * 0.002,
                    tasks: [
                        TASK_TYPES[Math.floor(Math.random() * TASK_TYPES.length)],
                        TASK_TYPES[Math.floor(Math.random() * TASK_TYPES.length)]
                    ],
                    state: 'orbiting' // orbiting, teaming
                };
                
                group.add(mesh);
                ftes.push(mesh);
            }
        }

        // JEFF Energy Hub
        function createJeff() {
            const jeffGeo = new THREE.TorusGeometry(32, 0.05, 16, 100);
            const jeffMat = new THREE.MeshBasicMaterial({ color: COLORS.JEFF, transparent: true, opacity: 0.1 });
            const ring = new THREE.Mesh(jeffGeo, jeffMat);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Neural Network Lightning
            const lineMat = new THREE.LineBasicMaterial({ color: COLORS.JEFF, transparent: true, opacity: 0.4 });
            for(let i=0; i<10; i++) {
                const lineGeo = new THREE.BufferGeometry();
                const line = new THREE.Line(lineGeo, lineMat);
                scene.add(line);
                lightningLines.push(line);
            }
        }

        // --- Logic ---
        function updateFTEs() {
            const time = Date.now() * 0.001;
            
            ftes.forEach(fte => {
                if (fte.userData.state === 'orbiting') {
                    fte.userData.originalAngle += fte.userData.orbitSpeed;
                    fte.position.x = Math.cos(fte.userData.originalAngle) * fte.userData.ringRadius;
                    fte.position.z = Math.sin(fte.userData.originalAngle) * fte.userData.ringRadius;
                    fte.position.y = Math.sin(time + fte.userData.id) * 0.5;
                }
            });

            // Barrel rotation
            barrelNodes.forEach((b, i) => {
                const angle = time * (0.2 + i * 0.05);
                b.position.x = Math.cos(angle + (i * Math.PI*2/5)) * 10;
                b.position.z = Math.sin(angle + (i * Math.PI*2/5)) * 10;
                b.rotation.y += 0.01;
                b.rotation.x += 0.005;
            });

            // Lightning Logic
            lightningLines.forEach((line, i) => {
                if (Math.random() > 0.95) {
                    const f1 = ftes[Math.floor(Math.random() * ftes.length)];
                    const f2 = ftes[Math.floor(Math.random() * ftes.length)];
                    const points = [f1.position.clone(), f2.position.clone()];
                    line.geometry.setFromPoints(points);
                    line.material.opacity = 0.6;
                    setTimeout(() => { line.material.opacity = 0; }, 100);
                }
            });
        }

        function triggerSwatTeam() {
            if (activeSprint) return;
            
            const teamSize = 3 + Math.floor(Math.random() * 5);
            const teamMembers = [];
            const shuffled = [...ftes].sort(() => 0.5 - Math.random());
            
            for(let i=0; i<teamSize; i++) {
                const fte = shuffled[i];
                if (fte.userData.state === 'orbiting') {
                    teamMembers.push(fte);
                    fte.userData.state = 'teaming';
                }
            }

            if (teamMembers.length < 2) return;

            const center = new THREE.Vector3(
                (Math.random()-0.5) * 20,
                (Math.random()-0.5) * 5,
                (Math.random()-0.5) * 20
            );

            activeSprint = { members: teamMembers, center: center };

            teamMembers.forEach((fte, i) => {
                const targetPos = center.clone().add(new THREE.Vector3(
                    Math.cos(i * Math.PI*2/teamMembers.length) * 3,
                    (Math.random()-0.5) * 2,
                    Math.sin(i * Math.PI*2/teamMembers.length) * 3
                ));

                new TWEEN.Tween(fte.position)
                    .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .start();
                
                fte.material.color.set(COLORS.JEFF);
            });

            setTimeout(() => {
                teamMembers.forEach(fte => {
                    fte.userData.state = 'orbiting';
                    fte.material.color.set(COLORS.FTE);
                });
                activeSprint = null;
                document.getElementById('sprint-info').style.display = 'none';
            }, 8000);
        }

        setInterval(triggerSwatTeam, 10000);

        // --- Event Handlers ---
        window.addEventListener('mousedown', (e) => { 
            isDragging = true;
            
            // Check for click on sprint
            if (activeSprint) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(activeSprint.members);
                if (intersects.length > 0) {
                    const info = document.getElementById('sprint-info');
                    info.style.display = 'block';
                    document.getElementById('sprint-details').innerText = `Rapid prototyping of ${activeSprint.members[0].userData.tasks[0]} and ${activeSprint.members[1].userData.tasks[1]}. Cross-functional alignment in progress.`;
                }
            }
        });
        
        window.addEventListener('mouseup', () => isDragging = false);
        
        window.addEventListener('mousemove', (e) => {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            if (isDragging) {
                group.rotation.y += deltaX * 0.005;
                group.rotation.x += deltaY * 0.005;
            }

            previousMousePosition = { x: e.clientX, y: e.clientY };

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(group.children, true);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.type === 'fte') {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 10 + 'px';
                    tooltip.style.top = e.clientY + 10 + 'px';
                    tooltip.innerHTML = `
                        <div class="tooltip-name">${obj.userData.name}</div>
                        <div class="tooltip-tasks">• ${obj.userData.tasks[0]}<br>• ${obj.userData.tasks[1]}</div>
                    `;
                    obj.scale.set(1.5, 1.5, 1.5);
                    hoveredObject = obj;
                } else if (obj.userData.type === 'barrel') {
                     // Barrel highlighting?
                }
            } else {
                document.getElementById('tooltip').style.display = 'none';
                if (hoveredObject) {
                    hoveredObject.scale.set(1, 1, 1);
                    hoveredObject = null;
                }
            }
        });

        window.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.05;
            camera.position.z = Math.max(10, Math.min(100, camera.position.z));
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            updateFTEs();
            renderer.render(scene, camera);
        }

        // Init
        createCore();
        createBarrels();
        createFTEs();
        createJeff();
        animate();

    </script>
</body>
</html>
