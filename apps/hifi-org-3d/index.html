<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HIFI Solar System Org Model - Neon Edition</title>
    <style>
        body {
            margin: 0;
            background-color: #050508;
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #container {
            flex-grow: 1;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        .title {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        .subtitle {
            font-size: 12px;
            color: #888;
            letter-spacing: 1px;
        }
        #tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(5, 5, 8, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            z-index: 20;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .tooltip-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
            color: #00f3ff;
        }
        .tooltip-tasks {
            font-size: 12px;
            color: #aaa;
        }
        #sprint-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            padding: 15px;
            background: rgba(5, 5, 8, 0.8);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 4px;
            display: none;
            z-index: 15;
            backdrop-filter: blur(10px);
        }
        .sprint-title {
            color: #00f3ff;
            font-weight: bold;
            margin-bottom: 8px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <div class="title">HIFI SYSTEM</div>
        <div class="subtitle">SERIES A ORG ARCHITECTURE</div>
    </div>
    <div id="tooltip"></div>
    <div id="sprint-info">
        <div class="sprint-title">SWAT TEAM FORMING</div>
        <div id="sprint-details" style="font-size: 12px; color: #ccc; line-height: 1.4;"></div>
        <div style="margin-top: 10px; font-size: 10px; color: #666;">POD ROTATION PAUSED</div>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/21.0.0/tween.umd.js"></script>

    <script>
        // --- Configuration ---
        const COLORS = {
            CORE: "#ffffff",
            ENGINEERING: "#06b6d4",
            COMPLIANCE: "#8b5cf6",
            MARKETING: "#f59e0b",
            GTM: "#10b981",
            OPS: "#f43f5e",
            FTE: "#888888",
            JEFF: "#06b6d4"
        };

        const BARRELS = [
            { name: "Compliance", color: COLORS.COMPLIANCE, angle: 0 },
            { name: "Marketing", color: COLORS.MARKETING, angle: (Math.PI * 2) / 5 },
            { name: "Engineering", color: COLORS.ENGINEERING, angle: (Math.PI * 2 * 2) / 5 },
            { name: "GTM", color: COLORS.GTM, angle: (Math.PI * 2 * 3) / 5 },
            { name: "Ops", color: COLORS.OPS, angle: (Math.PI * 2 * 4) / 5 }
        ];

        const TASK_TYPES = [
            "Smart Contract Audit", "Latency Optimization", "Growth Loop Design", 
            "Liquidity Scaling", "Risk Assessment", "API Integration", 
            "Brand Narrative", "Yield Strategy", "System Architecture",
            "Regulatory Mapping", "Partner Relations", "CI/CD Pipeline"
        ];

        // --- Setup Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050508);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 60); // Repositioned to see all galaxies
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        const group = new THREE.Group(); // Main Galaxy Group
        worldGroup.add(group);

        const menaGroup = new THREE.Group();
        menaGroup.position.set(-50, -5, -10);
        menaGroup.scale.set(0.6, 0.6, 0.6);
        worldGroup.add(menaGroup);

        const apacGroup = new THREE.Group();
        apacGroup.position.set(50, -5, -10);
        apacGroup.scale.set(0.6, 0.6, 0.6);
        worldGroup.add(apacGroup);

        // --- Interaction State ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        let activeSprint = null;

        // --- Components ---
        const ftes = [];
        const barrelNodes = [];
        const subsidiaryNodes = [];
        
        // Neon Glow Helper for Three.js
        function createNeonNode(size, color, opacity = 1) {
            const nodeGroup = new THREE.Group();
            
            // Core node
            const geo = new THREE.SphereGeometry(size, 32, 32);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            nodeGroup.add(mesh);
            
            // Neon Glow
            const glowGeo = new THREE.SphereGeometry(size * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.3 * opacity 
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            nodeGroup.add(glow);

            // Large Aura
            const auraGeo = new THREE.SphereGeometry(size * 3, 32, 32);
            const auraMat = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.1 * opacity 
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            nodeGroup.add(aura);
            
            return { nodeGroup, mesh };
        }

        // Subsidiary Creator
        function createSubsidiary(targetGroup, label, color) {
            const center = createNeonNode(2, COLORS.CORE);
            center.mesh.userData = { type: 'subsidiary_core', name: label };
            targetGroup.add(center.nodeGroup);

            // Small Orbiting Nodes
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const node = createNeonNode(0.8, color, 0.7);
                const radius = 6;
                node.nodeGroup.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                node.mesh.userData = { type: 'subsidiary_node', name: `${label} Node ${i+1}` };
                targetGroup.add(node.nodeGroup);
                subsidiaryNodes.push({ mesh: node.mesh, angle: angle, radius: radius });
            }

            // Connection Line to Main Galaxy
            const points = [
                new THREE.Vector3(0, 0, 0), // Local 0,0,0 of subsidiary
                targetGroup.position.clone().multiplyScalar(-1) // Direction to world center
            ];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
            const line = new THREE.Line(lineGeo, lineMat);
            targetGroup.add(line);
        }

        // LAYER 1: CORE (2 nodes: Mo, Zack)
        function createCore() {
            const createNode = (name, x) => {
                const { nodeGroup, mesh } = createNeonNode(1.2, COLORS.CORE);
                nodeGroup.position.x = x;
                mesh.userData = { type: 'core', name: name };
                group.add(nodeGroup);
                return nodeGroup;
            };

            const mo = createNode("Mo", -1.5);
            const zack = createNode("Zack", 1.5);
            
            // Pulsing animation
            function pulse() {
                const s = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                mo.scale.set(s, s, s);
                zack.scale.set(s, s, s);
                requestAnimationFrame(pulse);
            }
            pulse();
        }

        // LAYER 2: BARREL RING (Ring 1: 5 nodes)
        function createBarrels() {
            BARRELS.forEach((b, i) => {
                const { nodeGroup, mesh } = createNeonNode(1, b.color);
                nodeGroup.position.set(Math.cos(b.angle) * 10, 0, Math.sin(b.angle) * 10);
                mesh.userData = { type: 'barrel', name: b.name, color: b.color };
                group.add(nodeGroup);
                barrelNodes.push(nodeGroup);
                
                // Track mesh for raycasting
                mesh.userData.parentGroup = nodeGroup;
            });

            // Dotted Ring Circle
            const ringGeo = new THREE.TorusGeometry(10, 0.05, 16, 100);
            const ringMat = new THREE.LineDashedMaterial({ 
                color: 0x444444, 
                dashSize: 0.5, 
                gapSize: 0.5,
                transparent: true,
                opacity: 0.3
            });
            const ringMesh = new THREE.LineLoop(ringGeo, ringMat);
            ringMesh.computeLineDistances();
            ringMesh.rotation.x = Math.PI/2;
            group.add(ringMesh);
        }

        // LAYER 3 & 4: SWAT RINGS
        function createFTEs() {
            const DISTRIBUTION = [
                { count: 10, radius: 18, color: 0x444444 }, // Ring 2
                { count: 10, radius: 24, color: 0x444444 }, // Ring 3
                { count: 20, radius: 32, color: 0x444444 }  // Ring 4
            ];

            let globalCounter = 1;
            DISTRIBUTION.forEach((ringDef, ringIndex) => {
                // Dotted Ring Circle
                const ringGeo = new THREE.TorusGeometry(ringDef.radius, 0.03, 16, 150);
                const ringMat = new THREE.LineDashedMaterial({ 
                    color: 0x444444, 
                    dashSize: 0.4, 
                    gapSize: 0.6,
                    transparent: true,
                    opacity: 0.2
                });
                const ringCurve = new THREE.LineLoop(ringGeo, ringMat);
                ringCurve.computeLineDistances();
                ringCurve.rotation.x = Math.PI/2;
                group.add(ringCurve);

                for (let i = 0; i < ringDef.count; i++) {
                    const angle = (i / ringDef.count) * (Math.PI * 2);
                    
                    // Assign Barrel Color based on angle
                    const barrelIndex = Math.floor(((angle + Math.PI/5) % (Math.PI*2)) / (Math.PI*2/5));
                    const color = BARRELS[barrelIndex % 5].color;

                    const { nodeGroup, mesh } = createNeonNode(0.5, color, 0.8);
                    
                    const x = Math.cos(angle) * ringDef.radius;
                    const z = Math.sin(angle) * ringDef.radius;
                    nodeGroup.position.set(x, 0, z);
                    
                    mesh.userData = {
                        id: globalCounter,
                        name: `Unit ${String(globalCounter).padStart(2, '0')}`,
                        type: 'fte',
                        ringRadius: ringDef.radius,
                        originalAngle: angle,
                        orbitSpeed: 0.0005 + Math.random() * 0.001,
                        color: color,
                        barrelName: BARRELS[barrelIndex % 5].name,
                        tasks: [
                            TASK_TYPES[Math.floor(Math.random() * TASK_TYPES.length)],
                            TASK_TYPES[Math.floor(Math.random() * TASK_TYPES.length)]
                        ],
                        state: 'orbiting'
                    };
                    
                    group.add(nodeGroup);
                    ftes.push(mesh);
                    globalCounter++;
                }
            });
        }

        // Custom Wavy Connection Lines
        function createWavyLine(p1, p2, color) {
            const curve = new THREE.QuadraticBezierCurve3(
                p1,
                new THREE.Vector3((p1.x + p2.x)/2, (p1.y + p2.y)/2 + 5, (p1.z + p2.z)/2),
                p2
            );
            const points = curve.getPoints(20);
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0 });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            return line;
        }

        function createJeff() {
            const jeffGeo = new THREE.TorusGeometry(36, 0.05, 16, 100);
            const jeffMat = new THREE.MeshBasicMaterial({ color: COLORS.JEFF, transparent: true, opacity: 0.05 });
            const ring = new THREE.Mesh(jeffGeo, jeffMat);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
        }

        // --- Logic ---
        function updateFTEs() {
            const time = Date.now() * 0.001;
            
            ftes.forEach(fteMesh => {
                const fte = fteMesh.parent; // nodeGroup
                if (fteMesh.userData.state === 'orbiting') {
                    fteMesh.userData.originalAngle += fteMesh.userData.orbitSpeed;
                    fte.position.x = Math.cos(fteMesh.userData.originalAngle) * fteMesh.userData.ringRadius;
                    fte.position.z = Math.sin(fteMesh.userData.originalAngle) * fteMesh.userData.ringRadius;
                    fte.position.y = Math.sin(time + fteMesh.userData.id) * 0.3;
                }
            });

            // Barrel rotation
            barrelNodes.forEach((b, i) => {
                const angle = time * (0.1 + i * 0.02);
                b.position.x = Math.cos(angle + (i * Math.PI*2/5)) * 10;
                b.position.z = Math.sin(angle + (i * Math.PI*2/5)) * 10;
                b.rotation.y += 0.01;
            });

            // Dynamic Neon Connections (Wavy & Pulsing)
            if (Math.random() > 0.92) {
                const f1 = ftes[Math.floor(Math.random() * ftes.length)];
                const f2 = ftes[Math.floor(Math.random() * ftes.length)];
                
                // Get world positions
                const p1 = new THREE.Vector3();
                const p2 = new THREE.Vector3();
                f1.getWorldPosition(p1);
                f2.getWorldPosition(p2);

                const line = createWavyLine(p1, p2, f1.userData.color);
                
                new TWEEN.Tween({ opacity: 0 })
                    .to({ opacity: 0.6 }, 200)
                    .onUpdate((obj) => { line.material.opacity = obj.opacity; })
                    .chain(
                        new TWEEN.Tween({ opacity: 0.6 })
                        .to({ opacity: 0 }, 800)
                        .onUpdate((obj) => { line.material.opacity = obj.opacity; })
                        .onComplete(() => scene.remove(line))
                    )
                    .start();
            }
        }

        function triggerSwatTeam() {
            if (activeSprint) return;
            
            const teamSize = 3 + Math.floor(Math.random() * 5);
            const teamMembers = [];
            const shuffled = [...ftes].sort(() => 0.5 - Math.random());
            
            for(let i=0; i<teamSize; i++) {
                const fte = shuffled[i];
                if (fte.userData.state === 'orbiting') {
                    teamMembers.push(fte);
                    fte.userData.state = 'teaming';
                }
            }

            if (teamMembers.length < 2) return;

            const center = new THREE.Vector3(
                (Math.random()-0.5) * 15,
                (Math.random()-0.5) * 5,
                (Math.random()-0.5) * 15
            );

            activeSprint = { members: teamMembers, center: center };

            teamMembers.forEach((fteMesh, i) => {
                const fte = fteMesh.parent;
                const targetPos = center.clone().add(new THREE.Vector3(
                    Math.cos(i * Math.PI*2/teamMembers.length) * 3,
                    (Math.random()-0.5) * 2,
                    Math.sin(i * Math.PI*2/teamMembers.length) * 3
                ));

                new TWEEN.Tween(fte.position)
                    .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 2000)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .start();
            });

            setTimeout(() => {
                teamMembers.forEach(fteMesh => {
                    fteMesh.userData.state = 'orbiting';
                });
                activeSprint = null;
                document.getElementById('sprint-info').style.display = 'none';
            }, 8000);
        }

        setInterval(triggerSwatTeam, 12000);

        // --- Event Handlers ---
        window.addEventListener('mousedown', (e) => { 
            isDragging = true;
            
            if (activeSprint) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(activeSprint.members);
                if (intersects.length > 0) {
                    const info = document.getElementById('sprint-info');
                    info.style.display = 'block';
                    document.getElementById('sprint-details').innerText = `Rapid prototyping of ${activeSprint.members[0].userData.tasks[0]} and ${activeSprint.members[1].userData.tasks[1]}. Cross-functional alignment in progress.`;
                }
            }
        });
        
        window.addEventListener('mouseup', () => isDragging = false);
        
        window.addEventListener('mousemove', (e) => {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            if (isDragging) {
                worldGroup.rotation.y += deltaX * 0.005;
                worldGroup.rotation.x += deltaY * 0.005;
            }

            previousMousePosition = { x: e.clientX, y: e.clientY };

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(worldGroup.children, true);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.type === 'fte' || obj.userData.type === 'barrel' || obj.userData.type === 'core' || obj.userData.type === 'subsidiary_core' || obj.userData.type === 'subsidiary_node') {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'block';
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                    
                    if (obj.userData.type === 'fte') {
                        tooltip.innerHTML = `
                            <div class="tooltip-name" style="color:${obj.userData.color}">${obj.userData.name} [${obj.userData.barrelName}]</div>
                            <div class="tooltip-tasks">• ${obj.userData.tasks[0]}<br>• ${obj.userData.tasks[1]}</div>
                        `;
                    } else {
                        tooltip.innerHTML = `
                            <div class="tooltip-name" style="color:${obj.userData.color || '#fff'}">${obj.userData.name}</div>
                            <div class="tooltip-tasks">Core Architecture Node</div>
                        `;
                    }
                    
                    if (hoveredObject && hoveredObject !== obj) {
                        hoveredObject.parent.scale.set(1, 1, 1);
                    }
                    obj.parent.scale.set(1.3, 1.3, 1.3);
                    hoveredObject = obj;
                }
            } else {
                document.getElementById('tooltip').style.display = 'none';
                if (hoveredObject) {
                    hoveredObject.parent.scale.set(1, 1, 1);
                    hoveredObject = null;
                }
            }
        });

        window.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.05;
            camera.position.z = Math.max(10, Math.min(100, camera.position.z));
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            updateFTEs();
            
            // Update subsidiaries
            subsidiaryNodes.forEach(node => {
                const time = Date.now() * 0.001;
                node.angle += 0.01;
                node.mesh.parent.position.x = Math.cos(node.angle) * node.radius;
                node.mesh.parent.position.z = Math.sin(node.angle) * node.radius;
                node.mesh.parent.position.y = Math.sin(time + node.angle) * 0.2;
            });

            renderer.render(scene, camera);
        }

        // Init
        createCore();
        createBarrels();
        createFTEs();
        createJeff();
        createSubsidiary(menaGroup, "HIFI MENA LTD", COLORS.COMPLIANCE);
        createSubsidiary(apacGroup, "HIFI APAC LTD", COLORS.GTM);
        animate();

    </script>
</body>
</html>
